Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    COMMA
    DIVIDE
    DOLLAR
    EQUALITY
    FALSE
    GREATER
    LBRACKET
    LESS
    MINUS
    NOALIAS
    NOT
    NUMBER
    OR
    PLUS
    RBRACKET
    REF
    TIMES
    TRUE

Grammar

Rule 0     S' -> prog
Rule 1     prog -> funcs
Rule 2     prog -> externs funcs
Rule 3     externs -> extern
Rule 4     externs -> extern externs
Rule 5     funcs -> func
Rule 6     funcs -> func funcs
Rule 7     extern -> EXTERN TYPE ID LPAREN RPAREN SEMICOLON
Rule 8     extern -> EXTERN TYPE ID LPAREN tdecls RPAREN SEMICOLON
Rule 9     func -> DEF TYPE ID LPAREN RPAREN blk
Rule 10    func -> DEF TYPE ID LPAREN vdecls RPAREN blk
Rule 11    blk -> LBRACE RBRACE
Rule 12    blk -> LBRACE stmts RBRACE
Rule 13    stmts -> stmt
Rule 14    stmts -> stmt stmts
Rule 15    stmt -> blk
Rule 16    stmt -> RETURN SEMICOLON
Rule 17    stmt -> RETURN exp SEMICOLON
Rule 18    stmt -> vdecl EQUAL exp SEMICOLON
Rule 19    stmt -> exp SEMICOLON
Rule 20    stmt -> WHILE LPAREN exp RPAREN stmt
Rule 21    stmt -> IF LPAREN exp RPAREN stmt
Rule 22    stmt -> IF LPAREN exp RPAREN stmt ELSE stmt
Rule 23    stmt -> PRINT exp SEMICOLON
Rule 24    stmt -> PRINT SLIT SEMICOLON
Rule 25    TYPE -> INT
Rule 26    TYPE -> CINT
Rule 27    TYPE -> FLOAT
Rule 28    TYPE -> BOOL
Rule 29    TYPE -> VOID

Terminals, with rules where they appear

AND                  : 
BOOL                 : 28
CINT                 : 26
COMMA                : 
DEF                  : 9 10
DIVIDE               : 
DOLLAR               : 
ELSE                 : 22
EQUAL                : 18
EQUALITY             : 
EXTERN               : 7 8
FALSE                : 
FLOAT                : 27
GREATER              : 
ID                   : 7 8 9 10
IF                   : 21 22
INT                  : 25
LBRACE               : 11 12
LBRACKET             : 
LESS                 : 
LPAREN               : 7 8 9 10 20 21 22
MINUS                : 
NOALIAS              : 
NOT                  : 
NUMBER               : 
OR                   : 
PLUS                 : 
PRINT                : 23 24
RBRACE               : 11 12
RBRACKET             : 
REF                  : 
RETURN               : 16 17
RPAREN               : 7 8 9 10 20 21 22
SEMICOLON            : 7 8 16 17 18 19 23 24
SLIT                 : 24
TIMES                : 
TRUE                 : 
VOID                 : 29
WHILE                : 20
error                : 
exp                  : 17 18 19 20 21 22 23
tdecls               : 8
vdecl                : 18
vdecls               : 10

Nonterminals, with rules where they appear

TYPE                 : 7 8 9 10
blk                  : 9 10 15
extern               : 3 4
externs              : 2 4
func                 : 5 6
funcs                : 1 2 6
prog                 : 0
stmt                 : 13 14 20 21 22 22
stmts                : 12 14

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . funcs
    (2) prog -> . externs funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (3) externs -> . extern
    (4) externs -> . extern externs
    (9) func -> . DEF TYPE ID LPAREN RPAREN blk
    (10) func -> . DEF TYPE ID LPAREN vdecls RPAREN blk
    (7) extern -> . EXTERN TYPE ID LPAREN RPAREN SEMICOLON
    (8) extern -> . EXTERN TYPE ID LPAREN tdecls RPAREN SEMICOLON

    DEF             shift and go to state 6
    EXTERN          shift and go to state 7

    prog                           shift and go to state 1
    funcs                          shift and go to state 2
    externs                        shift and go to state 3
    func                           shift and go to state 4
    extern                         shift and go to state 5

state 1

    (0) S' -> prog .



state 2

    (1) prog -> funcs .

    $end            reduce using rule 1 (prog -> funcs .)


state 3

    (2) prog -> externs . funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (9) func -> . DEF TYPE ID LPAREN RPAREN blk
    (10) func -> . DEF TYPE ID LPAREN vdecls RPAREN blk

    DEF             shift and go to state 6

    funcs                          shift and go to state 8
    func                           shift and go to state 4

state 4

    (5) funcs -> func .
    (6) funcs -> func . funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (9) func -> . DEF TYPE ID LPAREN RPAREN blk
    (10) func -> . DEF TYPE ID LPAREN vdecls RPAREN blk

    $end            reduce using rule 5 (funcs -> func .)
    DEF             shift and go to state 6

    func                           shift and go to state 4
    funcs                          shift and go to state 9

state 5

    (3) externs -> extern .
    (4) externs -> extern . externs
    (3) externs -> . extern
    (4) externs -> . extern externs
    (7) extern -> . EXTERN TYPE ID LPAREN RPAREN SEMICOLON
    (8) extern -> . EXTERN TYPE ID LPAREN tdecls RPAREN SEMICOLON

    DEF             reduce using rule 3 (externs -> extern .)
    EXTERN          shift and go to state 7

    extern                         shift and go to state 5
    externs                        shift and go to state 10

state 6

    (9) func -> DEF . TYPE ID LPAREN RPAREN blk
    (10) func -> DEF . TYPE ID LPAREN vdecls RPAREN blk
    (25) TYPE -> . INT
    (26) TYPE -> . CINT
    (27) TYPE -> . FLOAT
    (28) TYPE -> . BOOL
    (29) TYPE -> . VOID

    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16

    TYPE                           shift and go to state 11

state 7

    (7) extern -> EXTERN . TYPE ID LPAREN RPAREN SEMICOLON
    (8) extern -> EXTERN . TYPE ID LPAREN tdecls RPAREN SEMICOLON
    (25) TYPE -> . INT
    (26) TYPE -> . CINT
    (27) TYPE -> . FLOAT
    (28) TYPE -> . BOOL
    (29) TYPE -> . VOID

    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16

    TYPE                           shift and go to state 17

state 8

    (2) prog -> externs funcs .

    $end            reduce using rule 2 (prog -> externs funcs .)


state 9

    (6) funcs -> func funcs .

    $end            reduce using rule 6 (funcs -> func funcs .)


state 10

    (4) externs -> extern externs .

    DEF             reduce using rule 4 (externs -> extern externs .)


state 11

    (9) func -> DEF TYPE . ID LPAREN RPAREN blk
    (10) func -> DEF TYPE . ID LPAREN vdecls RPAREN blk

    ID              shift and go to state 18


state 12

    (25) TYPE -> INT .

    ID              reduce using rule 25 (TYPE -> INT .)


state 13

    (26) TYPE -> CINT .

    ID              reduce using rule 26 (TYPE -> CINT .)


state 14

    (27) TYPE -> FLOAT .

    ID              reduce using rule 27 (TYPE -> FLOAT .)


state 15

    (28) TYPE -> BOOL .

    ID              reduce using rule 28 (TYPE -> BOOL .)


state 16

    (29) TYPE -> VOID .

    ID              reduce using rule 29 (TYPE -> VOID .)


state 17

    (7) extern -> EXTERN TYPE . ID LPAREN RPAREN SEMICOLON
    (8) extern -> EXTERN TYPE . ID LPAREN tdecls RPAREN SEMICOLON

    ID              shift and go to state 19


state 18

    (9) func -> DEF TYPE ID . LPAREN RPAREN blk
    (10) func -> DEF TYPE ID . LPAREN vdecls RPAREN blk

    LPAREN          shift and go to state 20


state 19

    (7) extern -> EXTERN TYPE ID . LPAREN RPAREN SEMICOLON
    (8) extern -> EXTERN TYPE ID . LPAREN tdecls RPAREN SEMICOLON

    LPAREN          shift and go to state 21


state 20

    (9) func -> DEF TYPE ID LPAREN . RPAREN blk
    (10) func -> DEF TYPE ID LPAREN . vdecls RPAREN blk

    RPAREN          shift and go to state 22
    vdecls          shift and go to state 23


state 21

    (7) extern -> EXTERN TYPE ID LPAREN . RPAREN SEMICOLON
    (8) extern -> EXTERN TYPE ID LPAREN . tdecls RPAREN SEMICOLON

    RPAREN          shift and go to state 24
    tdecls          shift and go to state 25


state 22

    (9) func -> DEF TYPE ID LPAREN RPAREN . blk
    (11) blk -> . LBRACE RBRACE
    (12) blk -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 27

    blk                            shift and go to state 26

state 23

    (10) func -> DEF TYPE ID LPAREN vdecls . RPAREN blk

    RPAREN          shift and go to state 28


state 24

    (7) extern -> EXTERN TYPE ID LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 29


state 25

    (8) extern -> EXTERN TYPE ID LPAREN tdecls . RPAREN SEMICOLON

    RPAREN          shift and go to state 30


state 26

    (9) func -> DEF TYPE ID LPAREN RPAREN blk .

    DEF             reduce using rule 9 (func -> DEF TYPE ID LPAREN RPAREN blk .)
    $end            reduce using rule 9 (func -> DEF TYPE ID LPAREN RPAREN blk .)


state 27

    (11) blk -> LBRACE . RBRACE
    (12) blk -> LBRACE . stmts RBRACE
    (13) stmts -> . stmt
    (14) stmts -> . stmt stmts
    (15) stmt -> . blk
    (16) stmt -> . RETURN SEMICOLON
    (17) stmt -> . RETURN exp SEMICOLON
    (18) stmt -> . vdecl EQUAL exp SEMICOLON
    (19) stmt -> . exp SEMICOLON
    (20) stmt -> . WHILE LPAREN exp RPAREN stmt
    (21) stmt -> . IF LPAREN exp RPAREN stmt
    (22) stmt -> . IF LPAREN exp RPAREN stmt ELSE stmt
    (23) stmt -> . PRINT exp SEMICOLON
    (24) stmt -> . PRINT SLIT SEMICOLON
    (11) blk -> . LBRACE RBRACE
    (12) blk -> . LBRACE stmts RBRACE

    RBRACE          shift and go to state 31
    RETURN          shift and go to state 35
    vdecl           shift and go to state 37
    exp             shift and go to state 36
    WHILE           shift and go to state 38
    IF              shift and go to state 39
    PRINT           shift and go to state 40
    LBRACE          shift and go to state 27

    stmts                          shift and go to state 32
    stmt                           shift and go to state 33
    blk                            shift and go to state 34

state 28

    (10) func -> DEF TYPE ID LPAREN vdecls RPAREN . blk
    (11) blk -> . LBRACE RBRACE
    (12) blk -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 27

    blk                            shift and go to state 41

state 29

    (7) extern -> EXTERN TYPE ID LPAREN RPAREN SEMICOLON .

    EXTERN          reduce using rule 7 (extern -> EXTERN TYPE ID LPAREN RPAREN SEMICOLON .)
    DEF             reduce using rule 7 (extern -> EXTERN TYPE ID LPAREN RPAREN SEMICOLON .)


state 30

    (8) extern -> EXTERN TYPE ID LPAREN tdecls RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 42


state 31

    (11) blk -> LBRACE RBRACE .

    DEF             reduce using rule 11 (blk -> LBRACE RBRACE .)
    $end            reduce using rule 11 (blk -> LBRACE RBRACE .)
    RETURN          reduce using rule 11 (blk -> LBRACE RBRACE .)
    vdecl           reduce using rule 11 (blk -> LBRACE RBRACE .)
    exp             reduce using rule 11 (blk -> LBRACE RBRACE .)
    WHILE           reduce using rule 11 (blk -> LBRACE RBRACE .)
    IF              reduce using rule 11 (blk -> LBRACE RBRACE .)
    PRINT           reduce using rule 11 (blk -> LBRACE RBRACE .)
    LBRACE          reduce using rule 11 (blk -> LBRACE RBRACE .)
    RBRACE          reduce using rule 11 (blk -> LBRACE RBRACE .)
    ELSE            reduce using rule 11 (blk -> LBRACE RBRACE .)


state 32

    (12) blk -> LBRACE stmts . RBRACE

    RBRACE          shift and go to state 43


state 33

    (13) stmts -> stmt .
    (14) stmts -> stmt . stmts
    (13) stmts -> . stmt
    (14) stmts -> . stmt stmts
    (15) stmt -> . blk
    (16) stmt -> . RETURN SEMICOLON
    (17) stmt -> . RETURN exp SEMICOLON
    (18) stmt -> . vdecl EQUAL exp SEMICOLON
    (19) stmt -> . exp SEMICOLON
    (20) stmt -> . WHILE LPAREN exp RPAREN stmt
    (21) stmt -> . IF LPAREN exp RPAREN stmt
    (22) stmt -> . IF LPAREN exp RPAREN stmt ELSE stmt
    (23) stmt -> . PRINT exp SEMICOLON
    (24) stmt -> . PRINT SLIT SEMICOLON
    (11) blk -> . LBRACE RBRACE
    (12) blk -> . LBRACE stmts RBRACE

    RBRACE          reduce using rule 13 (stmts -> stmt .)
    RETURN          shift and go to state 35
    vdecl           shift and go to state 37
    exp             shift and go to state 36
    WHILE           shift and go to state 38
    IF              shift and go to state 39
    PRINT           shift and go to state 40
    LBRACE          shift and go to state 27

    stmt                           shift and go to state 33
    stmts                          shift and go to state 44
    blk                            shift and go to state 34

state 34

    (15) stmt -> blk .

    RETURN          reduce using rule 15 (stmt -> blk .)
    vdecl           reduce using rule 15 (stmt -> blk .)
    exp             reduce using rule 15 (stmt -> blk .)
    WHILE           reduce using rule 15 (stmt -> blk .)
    IF              reduce using rule 15 (stmt -> blk .)
    PRINT           reduce using rule 15 (stmt -> blk .)
    LBRACE          reduce using rule 15 (stmt -> blk .)
    RBRACE          reduce using rule 15 (stmt -> blk .)
    ELSE            reduce using rule 15 (stmt -> blk .)


state 35

    (16) stmt -> RETURN . SEMICOLON
    (17) stmt -> RETURN . exp SEMICOLON

    SEMICOLON       shift and go to state 45
    exp             shift and go to state 46


state 36

    (19) stmt -> exp . SEMICOLON

    SEMICOLON       shift and go to state 47


state 37

    (18) stmt -> vdecl . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 48


state 38

    (20) stmt -> WHILE . LPAREN exp RPAREN stmt

    LPAREN          shift and go to state 49


state 39

    (21) stmt -> IF . LPAREN exp RPAREN stmt
    (22) stmt -> IF . LPAREN exp RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 50


state 40

    (23) stmt -> PRINT . exp SEMICOLON
    (24) stmt -> PRINT . SLIT SEMICOLON

    exp             shift and go to state 51
    SLIT            shift and go to state 52


state 41

    (10) func -> DEF TYPE ID LPAREN vdecls RPAREN blk .

    DEF             reduce using rule 10 (func -> DEF TYPE ID LPAREN vdecls RPAREN blk .)
    $end            reduce using rule 10 (func -> DEF TYPE ID LPAREN vdecls RPAREN blk .)


state 42

    (8) extern -> EXTERN TYPE ID LPAREN tdecls RPAREN SEMICOLON .

    EXTERN          reduce using rule 8 (extern -> EXTERN TYPE ID LPAREN tdecls RPAREN SEMICOLON .)
    DEF             reduce using rule 8 (extern -> EXTERN TYPE ID LPAREN tdecls RPAREN SEMICOLON .)


state 43

    (12) blk -> LBRACE stmts RBRACE .

    DEF             reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    $end            reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    RETURN          reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    vdecl           reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    exp             reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    WHILE           reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    IF              reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    PRINT           reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    LBRACE          reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    RBRACE          reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    ELSE            reduce using rule 12 (blk -> LBRACE stmts RBRACE .)


state 44

    (14) stmts -> stmt stmts .

    RBRACE          reduce using rule 14 (stmts -> stmt stmts .)


state 45

    (16) stmt -> RETURN SEMICOLON .

    RETURN          reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    vdecl           reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    exp             reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    PRINT           reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 16 (stmt -> RETURN SEMICOLON .)


state 46

    (17) stmt -> RETURN exp . SEMICOLON

    SEMICOLON       shift and go to state 53


state 47

    (19) stmt -> exp SEMICOLON .

    RETURN          reduce using rule 19 (stmt -> exp SEMICOLON .)
    vdecl           reduce using rule 19 (stmt -> exp SEMICOLON .)
    exp             reduce using rule 19 (stmt -> exp SEMICOLON .)
    WHILE           reduce using rule 19 (stmt -> exp SEMICOLON .)
    IF              reduce using rule 19 (stmt -> exp SEMICOLON .)
    PRINT           reduce using rule 19 (stmt -> exp SEMICOLON .)
    LBRACE          reduce using rule 19 (stmt -> exp SEMICOLON .)
    RBRACE          reduce using rule 19 (stmt -> exp SEMICOLON .)
    ELSE            reduce using rule 19 (stmt -> exp SEMICOLON .)


state 48

    (18) stmt -> vdecl EQUAL . exp SEMICOLON

    exp             shift and go to state 54


state 49

    (20) stmt -> WHILE LPAREN . exp RPAREN stmt

    exp             shift and go to state 55


state 50

    (21) stmt -> IF LPAREN . exp RPAREN stmt
    (22) stmt -> IF LPAREN . exp RPAREN stmt ELSE stmt

    exp             shift and go to state 56


state 51

    (23) stmt -> PRINT exp . SEMICOLON

    SEMICOLON       shift and go to state 57


state 52

    (24) stmt -> PRINT SLIT . SEMICOLON

    SEMICOLON       shift and go to state 58


state 53

    (17) stmt -> RETURN exp SEMICOLON .

    RETURN          reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    vdecl           reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    exp             reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    IF              reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    PRINT           reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    LBRACE          reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    RBRACE          reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    ELSE            reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)


state 54

    (18) stmt -> vdecl EQUAL exp . SEMICOLON

    SEMICOLON       shift and go to state 59


state 55

    (20) stmt -> WHILE LPAREN exp . RPAREN stmt

    RPAREN          shift and go to state 60


state 56

    (21) stmt -> IF LPAREN exp . RPAREN stmt
    (22) stmt -> IF LPAREN exp . RPAREN stmt ELSE stmt

    RPAREN          shift and go to state 61


state 57

    (23) stmt -> PRINT exp SEMICOLON .

    RETURN          reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    vdecl           reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    exp             reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    WHILE           reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    IF              reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    PRINT           reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    LBRACE          reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    RBRACE          reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    ELSE            reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)


state 58

    (24) stmt -> PRINT SLIT SEMICOLON .

    RETURN          reduce using rule 24 (stmt -> PRINT SLIT SEMICOLON .)
    vdecl           reduce using rule 24 (stmt -> PRINT SLIT SEMICOLON .)
    exp             reduce using rule 24 (stmt -> PRINT SLIT SEMICOLON .)
    WHILE           reduce using rule 24 (stmt -> PRINT SLIT SEMICOLON .)
    IF              reduce using rule 24 (stmt -> PRINT SLIT SEMICOLON .)
    PRINT           reduce using rule 24 (stmt -> PRINT SLIT SEMICOLON .)
    LBRACE          reduce using rule 24 (stmt -> PRINT SLIT SEMICOLON .)
    RBRACE          reduce using rule 24 (stmt -> PRINT SLIT SEMICOLON .)
    ELSE            reduce using rule 24 (stmt -> PRINT SLIT SEMICOLON .)


state 59

    (18) stmt -> vdecl EQUAL exp SEMICOLON .

    RETURN          reduce using rule 18 (stmt -> vdecl EQUAL exp SEMICOLON .)
    vdecl           reduce using rule 18 (stmt -> vdecl EQUAL exp SEMICOLON .)
    exp             reduce using rule 18 (stmt -> vdecl EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 18 (stmt -> vdecl EQUAL exp SEMICOLON .)
    IF              reduce using rule 18 (stmt -> vdecl EQUAL exp SEMICOLON .)
    PRINT           reduce using rule 18 (stmt -> vdecl EQUAL exp SEMICOLON .)
    LBRACE          reduce using rule 18 (stmt -> vdecl EQUAL exp SEMICOLON .)
    RBRACE          reduce using rule 18 (stmt -> vdecl EQUAL exp SEMICOLON .)
    ELSE            reduce using rule 18 (stmt -> vdecl EQUAL exp SEMICOLON .)


state 60

    (20) stmt -> WHILE LPAREN exp RPAREN . stmt
    (15) stmt -> . blk
    (16) stmt -> . RETURN SEMICOLON
    (17) stmt -> . RETURN exp SEMICOLON
    (18) stmt -> . vdecl EQUAL exp SEMICOLON
    (19) stmt -> . exp SEMICOLON
    (20) stmt -> . WHILE LPAREN exp RPAREN stmt
    (21) stmt -> . IF LPAREN exp RPAREN stmt
    (22) stmt -> . IF LPAREN exp RPAREN stmt ELSE stmt
    (23) stmt -> . PRINT exp SEMICOLON
    (24) stmt -> . PRINT SLIT SEMICOLON
    (11) blk -> . LBRACE RBRACE
    (12) blk -> . LBRACE stmts RBRACE

    RETURN          shift and go to state 35
    vdecl           shift and go to state 37
    exp             shift and go to state 36
    WHILE           shift and go to state 38
    IF              shift and go to state 39
    PRINT           shift and go to state 40
    LBRACE          shift and go to state 27

    stmt                           shift and go to state 62
    blk                            shift and go to state 34

state 61

    (21) stmt -> IF LPAREN exp RPAREN . stmt
    (22) stmt -> IF LPAREN exp RPAREN . stmt ELSE stmt
    (15) stmt -> . blk
    (16) stmt -> . RETURN SEMICOLON
    (17) stmt -> . RETURN exp SEMICOLON
    (18) stmt -> . vdecl EQUAL exp SEMICOLON
    (19) stmt -> . exp SEMICOLON
    (20) stmt -> . WHILE LPAREN exp RPAREN stmt
    (21) stmt -> . IF LPAREN exp RPAREN stmt
    (22) stmt -> . IF LPAREN exp RPAREN stmt ELSE stmt
    (23) stmt -> . PRINT exp SEMICOLON
    (24) stmt -> . PRINT SLIT SEMICOLON
    (11) blk -> . LBRACE RBRACE
    (12) blk -> . LBRACE stmts RBRACE

    RETURN          shift and go to state 35
    vdecl           shift and go to state 37
    exp             shift and go to state 36
    WHILE           shift and go to state 38
    IF              shift and go to state 39
    PRINT           shift and go to state 40
    LBRACE          shift and go to state 27

    stmt                           shift and go to state 63
    blk                            shift and go to state 34

state 62

    (20) stmt -> WHILE LPAREN exp RPAREN stmt .

    RETURN          reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    vdecl           reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    exp             reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    WHILE           reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    IF              reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    PRINT           reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    LBRACE          reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    RBRACE          reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    ELSE            reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)


state 63

    (21) stmt -> IF LPAREN exp RPAREN stmt .
    (22) stmt -> IF LPAREN exp RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    RETURN          reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    vdecl           reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    exp             reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    WHILE           reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    IF              reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    PRINT           reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    LBRACE          reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    RBRACE          reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    ELSE            shift and go to state 64

  ! ELSE            [ reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .) ]


state 64

    (22) stmt -> IF LPAREN exp RPAREN stmt ELSE . stmt
    (15) stmt -> . blk
    (16) stmt -> . RETURN SEMICOLON
    (17) stmt -> . RETURN exp SEMICOLON
    (18) stmt -> . vdecl EQUAL exp SEMICOLON
    (19) stmt -> . exp SEMICOLON
    (20) stmt -> . WHILE LPAREN exp RPAREN stmt
    (21) stmt -> . IF LPAREN exp RPAREN stmt
    (22) stmt -> . IF LPAREN exp RPAREN stmt ELSE stmt
    (23) stmt -> . PRINT exp SEMICOLON
    (24) stmt -> . PRINT SLIT SEMICOLON
    (11) blk -> . LBRACE RBRACE
    (12) blk -> . LBRACE stmts RBRACE

    RETURN          shift and go to state 35
    vdecl           shift and go to state 37
    exp             shift and go to state 36
    WHILE           shift and go to state 38
    IF              shift and go to state 39
    PRINT           shift and go to state 40
    LBRACE          shift and go to state 27

    stmt                           shift and go to state 65
    blk                            shift and go to state 34

state 65

    (22) stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .

    RETURN          reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    vdecl           reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    exp             reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    IF              reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    PRINT           reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    LBRACE          reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    RBRACE          reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 63 resolved as shift
